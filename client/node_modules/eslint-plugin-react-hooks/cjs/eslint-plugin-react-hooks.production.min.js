/** @license React vundefined
 * eslint-plugin-react-hooks.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';function K(a){if("Identifier"===a.type)return/^use[A-Z0-9].*$/.test(a.name);if("MemberExpression"===a.type&&!a.computed&&K(a.property)){a=a.object;var b=/^[A-Z].*/;return"Identifier"===a.type&&b.test(a.name)}return!1}function ba(a){return"Identifier"===a.type?!/^[a-z]/.test(a.name):!1}function ca(a,b){return a.name===b||"MemberExpression"===a.type&&"React"===a.object.name&&a.property.name===b}function fa(a){return!!(a.parent&&a.parent.callee&&ca(a.parent.callee,"forwardRef"))}
function ha(a){return!!(a.parent&&a.parent.callee&&ca(a.parent.callee,"memo"))}function ia(a){for(;a;){var b=ja(a);if(b&&(ba(b)||K(b))||fa(a)||ha(a))return!0;a=a.parent}return!1}
function ja(a){if("FunctionDeclaration"===a.type||"FunctionExpression"===a.type&&a.id)return a.id;if("FunctionExpression"===a.type||"ArrowFunctionExpression"===a.type)return"VariableDeclarator"===a.parent.type&&a.parent.init===a?a.parent.id:"AssignmentExpression"===a.parent.type&&a.parent.right===a&&"="===a.parent.operator?a.parent.left:"Property"!==a.parent.type||a.parent.value!==a||a.parent.computed?"AssignmentPattern"!==a.parent.type||a.parent.right!==a||a.parent.computed?void 0:a.parent.left:
a.parent.key}
function ka(a){function b(){return{isUsed:!1,isSatisfiedRecursively:!1,isSubtreeUsed:!1,children:new Map}}function e(a,c){c=c.split(".");var l=!0,e=!1,h=void 0;try{for(var d=c[Symbol.iterator](),k;!(l=(k=d.next()).done);l=!0){var f=k.value,x=a.children.get(f);x||(x=b(),a.children.set(f,x));a=x}}catch(J){e=!0,h=J}finally{try{l||null==d.return||d.return()}finally{if(e)throw h;}}return a}function f(a,b,c){b=b.split(".");var l=!0,e=!1,h=void 0;try{for(var d=b[Symbol.iterator](),k;!(l=(k=d.next()).done);l=
!0){var f=a.children.get(k.value);if(!f)break;c(f);a=f}}catch(J){e=!0,h=J}finally{try{l||null==d.return||d.return()}finally{if(e)throw h;}}}function h(a,b,c,e){a.children.forEach(function(a,l){var d=e(l);a.isSatisfiedRecursively?a.isSubtreeUsed&&c.add(d):a.isUsed?b.add(d):h(a,b,c,function(a){return d+"."+a})})}var y=a.dependencies,k=a.declaredDependencies,t=a.stableDependencies,u=a.externalDependencies,A=a.isEffect,r=b();y.forEach(function(a,b){e(r,b).isUsed=!0;f(r,b,function(a){a.isSubtreeUsed=!0})});
k.forEach(function(a){e(r,a.key).isSatisfiedRecursively=!0});t.forEach(function(a){e(r,a).isSatisfiedRecursively=!0});a=new Set;var d=new Set;h(r,a,d,function(a){return a});var c=[],B=new Set,v=new Set;k.forEach(function(a){a=a.key;d.has(a)?-1===c.indexOf(a)?c.push(a):v.add(a):!A||a.endsWith(".current")||u.has(a)?B.add(a):-1===c.indexOf(a)&&c.push(a)});a.forEach(function(a){c.push(a)});return{suggestedDependencies:c,unnecessaryDependencies:B,duplicateDependencies:v,missingDependencies:a}}
function O(a){switch(a.type){case "ObjectExpression":return"object";case "ArrayExpression":return"array";case "ArrowFunctionExpression":case "FunctionExpression":return"function";case "ClassExpression":return"class";case "ConditionalExpression":if(null!=O(a.consequent)||null!=O(a.alternate))return"conditional";break;case "LogicalExpression":if(null!=O(a.left)||null!=O(a.right))return"logical expression";break;case "JSXFragment":return"JSX fragment";case "JSXElement":return"JSX element";case "AssignmentExpression":if(null!=
O(a.right))return"assignment expression";break;case "NewExpression":return"object construction";case "Literal":if(a.value instanceof RegExp)return"regular expression";break;case "TypeCastExpression":return O(a.expression);case "TSAsExpression":return O(a.expression)}return null}
function ma(a){var b=a.declaredDependenciesNode,e=a.componentScope,f=a.scope;return a.declaredDependencies.map(function(a){var b=a.key;a=e.variables.find(function(a){return a.name===b});if(null==a)return null;var f=a.defs[0];if(null==f)return null;if("Variable"===f.type&&"VariableDeclarator"===f.node.type&&"Identifier"===f.node.id.type&&null!=f.node.init){var h=O(f.node.init);if(null!=h)return[a,h]}return"FunctionName"===f.type&&"FunctionDeclaration"===f.node.type?[a,"function"]:"ClassName"===f.type&&
"ClassDeclaration"===f.node.type?[a,"class"]:null}).filter(Boolean).map(function(a){var e=a[0];a=a[1];var h=e.defs[0];a:{for(var t=!1,u=0;u<e.references.length;u++){var A=e.references[u];if(A.writeExpr)if(t){e=!0;break a}else{t=!0;continue}for(var r=A.from;r!==f&&null!=r;)r=r.upper;if(r!==f&&!na(b,A.identifier)){e=!0;break a}}e=!1}return{construction:h,depType:a,isUsedOutsideOfHook:e}})}
function oa(a){return"MemberExpression"!==a.parent.type&&"OptionalMemberExpression"!==a.parent.type||a.parent.object!==a||"current"===a.parent.property.name||a.parent.computed||null!=a.parent.parent&&("CallExpression"===a.parent.parent.type||"OptionalCallExpression"===a.parent.parent.type)&&a.parent.parent.callee===a.parent?"MemberExpression"===a.type&&a.parent&&"AssignmentExpression"===a.parent.type&&a.parent.left===a?a.object:a:oa(a.parent)}
function X(a,b){if("Identifier"===a.type)return a=a.name,b&&b.set(a,!1),a;if("MemberExpression"!==a.type||a.computed){if("OptionalMemberExpression"!==a.type||a.computed)throw Error("Unsupported node type: "+a.type);var e=X(a.object,b),f=X(a.property,null);e=e+"."+f;b&&(a.optional?b.has(e)||b.set(e,!0):b.set(e,!1));return e}e=X(a.object,b);a=X(a.property,null);a=e+"."+a;b&&b.set(a,!1);return a}
function pa(a){return"MemberExpression"!==a.type||"Identifier"!==a.object.type||"React"!==a.object.name||"Identifier"!==a.property.type||a.computed?a:a.property}
function ra(a,b){var e=pa(a);if("Identifier"!==e.type)return-1;switch(e.name){case "useEffect":case "useLayoutEffect":case "useCallback":case "useMemo":return 0;case "useImperativeHandle":return 1;default:if(e===a&&b&&b.additionalHooks){try{var f=X(e,null)}catch(h){if(/Unsupported node type/.test(h.message))return 0;throw h;}return b.additionalHooks.test(f)?0:-1}return-1}}
function sa(a,b){for(var e=[a],f=null;e.length;){f=e.shift();if("Identifier"===f.type&&f.name===b.name&&f.range[0]===b.range[0]&&f.range[1]===b.range[1])return f;if(na(f,b)){a=0;for(var h=Object.entries(f);a<h.length;a++){var y=h[a],k=y[1];"parent"!==y[0]&&(ta(k)?(k.parent=f,e.push(k)):Array.isArray(k)&&k.forEach(function(a){ta(a)&&(a.parent=f,e.push(a))}))}}}return null}
function ua(a){for(var b="",e=0;e<a.length;e++)b+=a[e],0===e&&2===a.length?b+=" and ":e===a.length-2&&2<a.length?b+=", and ":e<a.length-1&&(b+=", ");return b}function ta(a){return"object"===typeof a&&null!==a&&!Array.isArray(a)&&"string"===typeof a.type}function na(a,b){return a.range[0]<=b.range[0]&&a.range[1]>=b.range[1]}exports.configs={recommended:{plugins:["react-hooks"],rules:{"react-hooks/rules-of-hooks":"error","react-hooks/exhaustive-deps":"warn"}}};
exports.rules={"rules-of-hooks":{meta:{type:"problem",docs:{description:"enforces the Rules of Hooks",category:"Possible Errors",recommended:!0,url:"https://reactjs.org/docs/hooks-rules.html"}},create:function(a){var b=[],e=[];return{onCodePathSegmentStart:function(a){return e.push(a)},onCodePathSegmentEnd:function(){return e.pop()},onCodePathStart:function(){return b.push(new Map)},onCodePathEnd:function(e,h){function f(a,b){var c=f.cache,d=c.get(a.id);b=new Set(b);if(b.has(a.id)){c=[].concat(b);
a=c.slice(c.indexOf(a.id)+1);c=!0;d=!1;var h=void 0;try{for(var l=a[Symbol.iterator](),g;!(c=(g=l.next()).done);c=!0)A.add(g.value)}catch(F){d=!0,h=F}finally{try{c||null==l.return||l.return()}finally{if(d)throw h;}}return 0}b.add(a.id);if(void 0!==d)return d;if(e.thrownSegments.includes(a))d=0;else if(0===a.prevSegments.length)d=1;else{d=0;l=!0;g=!1;var L=void 0;try{h=a.prevSegments[Symbol.iterator]();for(var M;!(l=(M=h.next()).done);l=!0)d+=f(M.value,b)}catch(F){g=!0,L=F}finally{try{l||null==h.return||
h.return()}finally{if(g)throw L;}}}a.reachable&&0===d?c.delete(a.id):c.set(a.id,d);return d}function k(a,b){var d=k.cache,c=d.get(a.id);b=new Set(b);if(b.has(a.id)){d=Array.from(b);a=d.slice(d.indexOf(a.id)+1);d=!0;c=!1;var f=void 0;try{for(var h=a[Symbol.iterator](),g;!(d=(g=h.next()).done);d=!0)A.add(g.value)}catch(F){c=!0,f=F}finally{try{d||null==h.return||h.return()}finally{if(c)throw f;}}return 0}b.add(a.id);if(void 0!==c)return c;if(e.thrownSegments.includes(a))c=0;else if(0===a.nextSegments.length)c=
1;else{c=0;h=!0;g=!1;var L=void 0;try{f=a.nextSegments[Symbol.iterator]();for(var M;!(h=(M=f.next()).done);h=!0)c+=k(M.value,b)}catch(F){g=!0,L=F}finally{try{h||null==f.return||f.return()}finally{if(g)throw L;}}}d.set(a.id,c);return c}function t(a){var b=t.cache,c=b.get(a.id);if(null===c)return Infinity;if(void 0!==c)return c;b.set(a.id,null);if(0===a.prevSegments.length)c=1;else{c=Infinity;var d=!0,e=!1,f=void 0;try{for(var g=a.prevSegments[Symbol.iterator](),L;!(d=(L=g.next()).done);d=!0){var M=
t(L.value);M<c&&(c=M)}}catch(F){e=!0,f=F}finally{try{d||null==g.return||g.return()}finally{if(e)throw f;}}c+=1}b.set(a.id,c);return c}var u=b.pop();if(0!==u.size){var A=new Set;f.cache=new Map;k.cache=new Map;t.cache=new Map;var r=k(e.initialSegment),d=ja(h),c=ia(h),B=d?ba(d)||K(d):fa(h)||ha(h),v=Infinity,l=!0,x=!1,I=void 0;try{for(var Q=e.finalSegments[Symbol.iterator](),p;!(l=(p=Q.next()).done);l=!0){var la=p.value;if(la.reachable){var z=t(la);z<v&&(v=z)}}}catch(E){x=!0,I=E}finally{try{l||null==
Q.return||Q.return()}finally{if(x)throw I;}}l=!0;x=!1;I=void 0;try{for(var n=u[Symbol.iterator](),U;!(l=(U=n.next()).done);l=!0){var J=U.value,C=J[0],w=J[1];if(C.reachable){var Z=0===C.nextSegments.length?v<=t(C):v<t(C),W=f(C)*k(C),P=A.has(C.id);u=!0;Q=!1;p=void 0;try{for(var G=w[Symbol.iterator](),N;!(u=(N=G.next()).done);u=!0){var m=N.value;P&&a.report({node:m,message:'React Hook "'+a.getSource(m)+'" may be executed more than once. Possibly because it is called in a loop. React Hooks must be called in the exact same order in every component render.'});
if(B){if(!P&&W!==r){var D='React Hook "'+a.getSource(m)+'" is called conditionally. React Hooks must be called in the exact same order in every component render.'+(Z?" Did you accidentally call a React Hook after an early return?":"");a.report({node:m,message:D})}}else if(h.parent&&("MethodDefinition"===h.parent.type||"ClassProperty"===h.parent.type)&&h.parent.value===h){var aa='React Hook "'+a.getSource(m)+'" cannot be called in a class component. React Hooks must be called in a React function component or a custom React Hook function.';
a.report({node:m,message:aa})}else if(d){var S='React Hook "'+a.getSource(m)+'" is called in function "'+(a.getSource(d)+'" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter.');a.report({node:m,message:S})}else if("Program"===h.type){var T='React Hook "'+a.getSource(m)+'" cannot be called at the top level. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:m,
message:T})}else if(c){var H='React Hook "'+a.getSource(m)+'" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:m,message:H})}}}catch(E){Q=!0,p=E}finally{try{u||null==G.return||G.return()}finally{if(Q)throw p;}}}}}catch(E){x=!0,I=E}finally{try{l||null==n.return||n.return()}finally{if(x)throw I;}}}},CallExpression:function(a){if(K(a.callee)){var f=b[b.length-1],y=e[e.length-1],k=f.get(y);k||(k=[],f.set(y,k));
k.push(a.callee)}}}}},"exhaustive-deps":{meta:{type:"suggestion",docs:{description:"verifies the list of dependencies for Hooks like useEffect and similar",category:"Best Practices",recommended:!0,url:"https://github.com/facebook/react/issues/14920"},fixable:"code",schema:[{type:"object",additionalProperties:!1,enableDangerousAutofixThisMayCauseInfiniteLoops:!1,properties:{additionalHooks:{type:"string"},enableDangerousAutofixThisMayCauseInfiniteLoops:{type:"boolean"}}}]},create:function(a){function b(b){h&&
Array.isArray(b.suggest)&&0<b.suggest.length&&(b.fix=b.suggest[0].fix);a.report(b)}function e(a,b){return function(c){if(b.has(c))return b.get(c);var d=a(c);b.set(c,d);return d}}function f(d,c,f,h,l){function x(a){var g=!0,b=!1,c=void 0;try{for(var f=a.references[Symbol.iterator](),e;!(g=(e=f.next()).done);g=!0){var h=e.value;if(h.resolved&&y.has(h.resolved.scope)){var m=sa(d,h.identifier),k=oa(m),v=X(k,Z),p;if(p=l&&"Identifier"===k.type&&("MemberExpression"===k.parent.type||"OptionalMemberExpression"===
k.parent.type)&&!k.parent.computed&&"Identifier"===k.parent.property.type&&"current"===k.parent.property.name){for(var n=h.from,B=!1;n.block!==d;)"function"===n.type&&(B=null!=n.block.parent&&"ReturnStatement"===n.block.parent.type),n=n.upper;p=B}p&&C.set(v,{reference:h,dependencyNode:k});if("TSTypeQuery"!==k.parent.type){var q=h.resolved.defs[0];if(null!=q&&(null==q.node||q.node.init!==d.parent)&&"TypeParameter"!==q.type)if(w.has(v))w.get(v).references.push(h);else{var t=h.resolved,u=U(t)||J(t);
w.set(v,{isStable:u,references:[h]})}}}}}catch(ea){b=!0,c=ea}finally{try{g||null==f.return||f.return()}finally{if(b)throw c;}}g=!0;b=!1;c=void 0;try{for(var r=a.childScopes[Symbol.iterator](),I;!(g=(I=r.next()).done);g=!0)x(I.value)}catch(ea){b=!0,c=ea}finally{try{g||null==r.return||r.return()}finally{if(b)throw c;}}}function v(a){a=a.split(".");for(var g="",b=0;b<a.length;b++){if(0!==b){var c=a.slice(0,b+1).join(".");c=!0===Z.get(c);g+=c?"?.":"."}g+=a[b]}return g}function B(a,b,c,f){return 0===a.size?
null:(1<a.size?"":b+" ")+c+" "+(1<a.size?"dependencies":"dependency")+": "+ua(Array.from(a).sort().map(function(a){return"'"+v(a)+"'"}))+(". Either "+f+" "+(1<a.size?"them":"it")+" or remove the dependency array.")}l&&d.async&&b({node:d,message:"Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching"});
for(var p=k.acquire(d),y=new Set,z=null,n=p.upper;n;){y.add(n);if("function"===n.type)break;n=n.upper}if(n){z=n;var U=e(function(a){if(!Array.isArray(a.defs))return!1;var b=a.defs[0];if(null==b||"VariableDeclarator"!==b.node.type)return!1;var g=b.node.init;if(null==g)return!1;for(;"TSAsExpression"===g.type;)g=g.expression;var c=b.node.parent;if(null==c&&(sa(z.block,b.node.id),c=b.node.parent,null==c))return!1;if("const"===c.kind&&"Literal"===g.type&&("string"===typeof g.value||"number"===typeof g.value||
null===g.value))return!0;if("CallExpression"!==g.type)return!1;g=g.callee;"MemberExpression"!==g.type||"React"!==g.object.name||null==g.property||g.computed||(g=g.property);if("Identifier"!==g.type)return!1;b=b.node.id;g=g.name;if("useRef"===g&&"Identifier"===b.type)return!0;if(("useState"===g||"useReducer"===g)&&"ArrayPattern"===b.type&&2===b.elements.length&&Array.isArray(a.identifiers)){if(b.elements[1]===a.identifiers[0]){if("useState"===g)for(a=a.references,g=0;g<a.length;g++)t.set(a[g].identifier,
b.elements[0]);return!0}if(b.elements[0]===a.identifiers[0]&&"useState"===g)for(a=a.references,b=0;b<a.length;b++)u.add(a[b].identifier)}return!1},A),J=e(function(a){if(!Array.isArray(a.defs))return!1;a=a.defs[0];if(null==a||null==a.node||null==a.node.id)return!1;var b=a.node,g=z.childScopes;a=null;var c;for(c=0;c<g.length;c++){var f=g[c],d=f.block;if("FunctionDeclaration"===b.type&&d===b||"VariableDeclarator"===b.type&&d.parent===b){a=f;break}}if(null==a)return!1;for(c=0;c<a.through.length;c++)if(b=
a.through[c],null!=b.resolved&&y.has(b.resolved.scope)&&!U(b.resolved))return!1;return!0},r),C=new Map,w=new Map,Z=new Map;x(p);C.forEach(function(a,c){var g=a.dependencyNode;a=a.reference.resolved.references;for(var f=!1,d=0;d<a.length;d++){var e=a[d].identifier.parent;if(null!=e&&"MemberExpression"===e.type&&!e.computed&&"Identifier"===e.property.type&&"current"===e.property.name&&"AssignmentExpression"===e.parent.type&&e.parent.left===e){f=!0;break}}f||b({node:g.parent.property,message:"The ref value '"+
c+".current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy '"+(c+".current' to a variable inside the effect, and use that variable in the cleanup function.")})});var W=new Set,P=new Set;w.forEach(function(c,d){var g=c.references;c.isStable&&P.add(d);g.forEach(function(c){c.writeExpr&&(c=c.writeExpr,W.has(d)||(W.add(d),b({node:c,message:"Assignments to the '"+d+"' variable from inside React Hook "+(a.getSource(f)+" will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside ")+
(a.getSource(f)+".")})))})});if(!(0<W.size))if(c){var G=[],N=new Set;"ArrayExpression"!==c.type?b({node:c,message:"React Hook "+a.getSource(f)+" was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies."}):c.elements.forEach(function(c){if(null!==c)if("SpreadElement"===c.type)b({node:c,message:"React Hook "+a.getSource(f)+" has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies."});
else{try{var g=X(c,null)}catch(qa){if(/Unsupported node type/.test(qa.message)){"Literal"===c.type?w.has(c.value)?b({node:c,message:"The "+c.raw+" literal is not a valid dependency because it never changes. Did you mean to include "+(c.value+" in the array instead?")}):b({node:c,message:"The "+c.raw+" literal is not a valid dependency because it never changes. You can safely remove it."}):b({node:c,message:"React Hook "+a.getSource(f)+" has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked."});
return}throw qa;}for(var d=c;"MemberExpression"===d.type||"OptionalMemberExpression"===d.type;)d=d.object;var e=!z.through.some(function(a){return a.identifier===d});G.push({key:g,node:c});e||N.add(g)}});var m=ka({dependencies:w,declaredDependencies:G,stableDependencies:P,externalDependencies:N,isEffect:l});n=m.unnecessaryDependencies;var D=m.missingDependencies,aa=m.duplicateDependencies,S=m.suggestedDependencies;if(0===aa.size+D.size+n.size)ma({declaredDependencies:G,declaredDependenciesNode:c,
componentScope:z,scope:p}).forEach(function(a){var g=a.construction,d=a.isUsedOutsideOfHook;a=a.depType;var f="function"===a?"useCallback":"useMemo",e="function"===a?"definition":"initialization",l="wrap the "+e+" of '"+g.name.name+"' in its own "+f+"() Hook.";l="The '"+g.name.name+"' "+a+" "+("conditional"===a||"logical expression"===a?"could make":"makes")+" the dependencies of "+(h+" Hook (at line "+c.loc.start.line+") change on every render. ")+(d?"To fix this, "+l:"Move it inside the "+h+" callback. Alternatively, "+
l);var k;d&&"Variable"===g.type&&"function"===a&&(k=[{desc:"Wrap the "+e+" of '"+g.name.name+"' in its own "+f+"() Hook.",fix:function(a){var b="useMemo"===f?["useMemo(() => { return ","; })"]:["useCallback(",")"],c=b[1];return[a.insertTextBefore(g.node.init,b[0]),a.insertTextAfter(g.node.init,c)]}}]);b({node:g.node,message:l,suggest:k})});else{!l&&0<D.size&&(S=ka({dependencies:w,declaredDependencies:[],stableDependencies:P,externalDependencies:N,isEffect:l}).suggestedDependencies);(function(){if(0===
G.length)return!0;var a=G.map(function(a){return a.key}),b=a.slice().sort();return a.join(",")===b.join(",")})()&&S.sort();m="";if(0<n.size){var T=null;Array.from(n.keys()).forEach(function(a){null===T&&a.endsWith(".current")&&(T=a)});if(null!==T)m=" Mutable values like '"+T+"' aren't valid dependencies because mutating them doesn't re-render the component.";else if(0<N.size){var H=Array.from(N)[0];p.set.has(H)||(m=" Outer scope values like '"+H+"' aren't valid dependencies because mutating them doesn't re-render the component.")}}if(!m&&
D.has("props")){p=w.get("props");if(null==p)return;p=p.references;if(!Array.isArray(p))return;H=!0;for(var E=0;E<p.length;E++){var R=sa(z.block,p[E].identifier);if(!R){H=!1;break}R=R.parent;if(null==R){H=!1;break}if("MemberExpression"!==R.type&&"OptionalMemberExpression"!==R.type){H=!1;break}}H&&(m=" However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the "+(h+" call and refer to those specific props inside ")+(a.getSource(f)+
"."))}if(!m&&0<D.size){var Y=null;D.forEach(function(a){if(!Y){var b=z.set.get(a),c=w.get(a);if(c.references[0].resolved===b&&(b=b.defs[0],null!=b&&null!=b.name&&"Parameter"===b.type)){b=!1;for(var d,g=0;g<c.references.length;g++)if(d=c.references[g].identifier,null!=d&&null!=d.parent&&("CallExpression"===d.parent.type||"OptionalCallExpression"===d.parent.type)&&d.parent.callee===d){b=!0;break}b&&(Y=a)}}});null!==Y&&(m=" If '"+Y+"' changes too often, find the parent component that defines it and wrap that definition in useCallback.")}if(!m&&
0<D.size){var q=null;D.forEach(function(a){if(null===q)for(var b=w.get(a).references,c,d,g=0;g<b.length;g++){c=b[g].identifier;for(d=c.parent;null!=d&&d!==z.block;){if("CallExpression"===d.type){var f=t.get(d.callee);if(null!=f){f.name===a?q={missingDep:a,setter:d.callee.name,form:"updater"}:u.has(c)?q={missingDep:a,setter:d.callee.name,form:"reducer"}:(c=b[g].resolved,null!=c&&(c=c.defs[0],null!=c&&"Parameter"===c.type&&(q={missingDep:a,setter:d.callee.name,form:"inlineReducer"})));break}}d=d.parent}if(null!==
q)break}});if(null!==q)switch(q.form){case "reducer":m=" You can also replace multiple useState variables with useReducer if '"+(q.setter+"' needs the current value of '")+(q.missingDep+"'.");break;case "inlineReducer":m=" If '"+q.setter+"' needs the current value of '"+(q.missingDep+"', you can also switch to useReducer instead of useState and read '")+(q.missingDep+"' in the reducer.");break;case "updater":m=" You can also do a functional update '"+q.setter+"("+q.missingDep.substring(0,1)+" => ...)' if you only need '"+
q.missingDep+"' in the '"+(q.setter+"' call.");break;default:throw Error("Unknown case.");}}b({node:c,message:"React Hook "+a.getSource(f)+" has "+(B(D,"a","missing","include")||B(n,"an","unnecessary","exclude")||B(aa,"a","duplicate","omit"))+m,suggest:[{desc:"Update the dependencies array to be: ["+S.map(v).join(", ")+"]",fix:function(a){return a.replaceText(c,"["+S.map(v).join(", ")+"]")}}]})}}else{var V=null;w.forEach(function(a,b){V||a.references.forEach(function(a){if(!V&&t.has(a.identifier)){for(a=
a.from;"function"!==a.type;)a=a.upper;a.block===d&&(V=b)}})});if(V){var da=ka({dependencies:w,declaredDependencies:[],stableDependencies:P,externalDependencies:new Set,isEffect:!0}).suggestedDependencies;b({node:f,message:"React Hook "+h+" contains a call to '"+V+"'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass ["+da.join(", ")+("] as a second argument to the "+h+" Hook."),suggest:[{desc:"Add dependencies array: ["+da.join(", ")+"]",fix:function(a){return a.insertTextAfter(d,
", ["+da.join(", ")+"]")}}]})}}}}var h=a.options&&a.options[0]&&a.options[0].enableDangerousAutofixThisMayCauseInfiniteLoops||!1,y={additionalHooks:a.options&&a.options[0]&&a.options[0].additionalHooks?new RegExp(a.options[0].additionalHooks):void 0,enableDangerousAutofixThisMayCauseInfiniteLoops:h},k=a.getSourceCode().scopeManager,t=new WeakMap,u=new WeakSet,A=new WeakMap,r=new WeakMap;return{CallExpression:function(d){var c=ra(d.callee,y);if(-1!==c){var e=d.arguments[c],h=d.callee,l=pa(h).name,
k=d.arguments[c+1];d=/Effect($|[^a-z])/g.test(l);if(k||d){switch(e.type){case "FunctionExpression":case "ArrowFunctionExpression":f(e,k,h,l,d);return;case "Identifier":if(!k||k.elements&&k.elements.some(function(a){return a&&"Identifier"===a.type&&a.name===e.name}))return;c=a.getScope().set.get(e.name);if(null==c||null==c.defs)return;c=c.defs[0];if(!c||!c.node)break;if("Variable"!==c.type&&"FunctionName"!==c.type)break;switch(c.node.type){case "FunctionDeclaration":f(c.node,k,h,l,d);return;case "VariableDeclarator":if(c=
c.node.init)switch(c.type){case "ArrowFunctionExpression":case "FunctionExpression":f(c,k,h,l,d);return}}break;default:b({node:h,message:"React Hook "+l+" received a function whose dependencies are unknown. Pass an inline function instead."});return}b({node:h,message:"React Hook "+l+" has a missing dependency: '"+e.name+"'. Either include it or remove the dependency array.",suggest:[{desc:"Update the dependencies array to be: ["+e.name+"]",fix:function(a){return a.replaceText(k,"["+e.name+"]")}}]})}else"useMemo"!==
l&&"useCallback"!==l||b({node:h,message:"React Hook "+l+" does nothing when called with only one argument. Did you forget to pass an array of dependencies?"})}}}}}};
